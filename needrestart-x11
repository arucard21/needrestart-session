#!/usr/bin/perl

# needrestart-x11 - X11 frontend for needrestart
#
# Authors:
#   Thomas Liske <thomas@fiasko-nw.net>
#
# Copyright Holder:
#   2014 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

use warnings;
use strict;

use NeedRestart::Utils;
use Wx qw(wxDefaultPosition wxDefaultSize wxPD_ELAPSED_TIME wxLC_REPORT wxALL wxTOP wxBOTTOM wxLIST_AUTOSIZE wxHORIZONTAL wxALIGN_CENTER wxEXPAND wxID_CLOSE wxID_REFRESH wxUSER_ATTENTION_INFO wxST_ELLIPSIZE_END);
use Wx::Event qw(EVT_BUTTON EVT_LIST_ITEM_ACTIVATED EVT_CLOSE);
use List::Util qw(max);
use Proc::ProcessTable;
use Cwd qw(realpath);

# get current session
my $csession;
if(open(HCGROUP, qq(/proc/$$/cgroup))) {
    map {
	chomp;
	my ($id, $type, $value) = split(/:/);
	$csession = $2 if($type eq q(name=systemd) && $value =~ m@/user-(\d+).slice/(session-\d+).scope@);
    } <HCGROUP>;
    close(HCGROUP);
}
my @plist;

# prepare GUI stuff
my $app = Wx::SimpleApp->new;
$app->SetAppName('needrestart-x11');

my $frame = Wx::Frame->new(undef, -1, 'needrestart-x11');

my $sApps = Wx::StaticText->new($frame, -1, 'Some background processes need to be restarted manually. You might need to logout and login:', wxDefaultPosition, wxDefaultSize, wxST_ELLIPSIZE_END);
my $lApps = Wx::ListCtrl->new($frame, -1, wxDefaultPosition, [640, 480], wxLC_REPORT);
$lApps->InsertColumn(0, "Application");
$lApps->InsertColumn(1, "Session Type");
$lApps->InsertColumn(2, "Session Id");
$lApps->InsertColumn(3, "PID");

&RefreshAppsList;

$lApps->SetColumnWidth(0, wxLIST_AUTOSIZE);
$lApps->SetColumnWidth(1, wxLIST_AUTOSIZE);
$lApps->SetColumnWidth(2, wxLIST_AUTOSIZE);
$lApps->SetColumnWidth(3, wxLIST_AUTOSIZE);

my $bsButtons = Wx::BoxSizer->new(wxHORIZONTAL);
my $bRecheck = Wx::Button->new($frame, wxID_REFRESH);
my $bClose = Wx::Button->new($frame, wxID_CLOSE);

my $fgs = Wx::FlexGridSizer->new(5, 1, 0, 0);
$fgs->Add($sApps, 0, wxEXPAND | wxTOP | wxBOTTOM, 4);
$fgs->Add($lApps, 0, wxEXPAND);
$bsButtons->Add($bRecheck, 0, wxALL, 4);
$bsButtons->Add($bClose, 0, wxALL, 4);
$fgs->Add($bsButtons, 0, wxALIGN_CENTER);

$fgs->AddGrowableCol(0);
$fgs->AddGrowableRow(1);

$frame->SetSizerAndFit($fgs);
$frame->SetAutoLayout(1);
$frame->Centre();

# bind event handlers
EVT_BUTTON($frame, $bRecheck, \&OnRecheck);
EVT_BUTTON($frame, $bClose, \&OnClose);
EVT_CLOSE($frame, \&OnClose);
EVT_LIST_ITEM_ACTIVATED($frame, $lApps, \&OnAppsDClick);

# show main window and enter event loop
$frame->Show;
$frame->RequestUserAttention(wxUSER_ATTENTION_INFO);
$app->MainLoop;

sub RefreshAppsList {
    my $frProgress = Wx::ProgressDialog->new("", "", 4, undef, wxPD_ELAPSED_TIME);

    # get user processes required to be restarted
    my %fnames;
    my $fh = nr_fork_pipe(0, qw(needrestart -b));
    $frProgress->SetTitle(q(Scanning processes...));
    while(<$fh>) {
	chomp;

	next unless(/^NEEDRESTART-PID: (.+)=([\d,]+)$/);

	@{ $fnames{$1} } = split(/,/, $2);
	$frProgress->Update(1, $1);
	$frProgress->Pulse;
    }
    close($fh);

    # terminate if no orphan process is found
    if(scalar keys %fnames == 0) {
	$frProgress->Destroy;

	my $msg = Wx::MessageDialog->new($frame, "None of your processes need to be restarted.", "Nothing found...");
	$msg->ShowModal;
	$msg->Destroy;
	exit;
    }
    
    # get list of pid => window mapping
    $frProgress->SetTitle(q(Scanning X11 windows...));
    my %ptable = map {$_->pid => $_} @{ new Proc::ProcessTable(enable_ttys => 1)->table };
    my %windows;
    my %wtitles;
    $fh = nr_fork_pipe(0, qw(wmctrl -l -p));
    while(<$fh>) {
	chomp;

	next unless(/^(0x[\da-f]+) +-?\d+ +(\d+) +(.+)/);

	$windows{$2} = $1;
	$wtitles{$2} = $3;
	$frProgress->Update(2, $ptable{$2}->{fname});
	$frProgress->Pulse;
    }
    close($fh);

    # build process list from `needrestart` and `wmctrl` outputs
    $frProgress->SetTitle(q(Updating list...));
    @plist = ();
    foreach my $fname (keys %fnames) {
	foreach my $pid (@{$fnames{$fname}}) {
	    my $session = '?';
	    my $type = '';
	    if(exists($ptable{$pid})) {
		if($ptable{$pid}->{ttydev} ne '') {
		    $session = realpath( $ptable{$pid}->{ttydev} );
	    }
		elsif(open(HCGROUP, qq(/proc/$pid/cgroup))) {
		    map {
			chomp;
			my ($id, $type, $value) = split(/:/);
			$session = $2 if($type eq q(name=systemd) && $value =~ m@/user-(\d+).slice/(session-\d+).scope@);
		    } <HCGROUP>;
		    close(HCGROUP);
		}

		if(defined($csession) && $session ne '?') {
		    $type = ($session eq $csession ? 'current' : 'foreign');
		}
	    }

	    my $data = {
		fname => $fname,
		pid => $pid,
		sessid => $session,
		sessty => $type,
	    };

	    if(grep { $_ == $pid } keys %windows) {
		$data->{winid} = $windows{$pid};
		$data->{winti} = $wtitles{$pid};
	    }

	    push(@plist, $data);
	}

	$frProgress->Update(3, $fname);
	$frProgress->Pulse;
    }

    # sort processes by session, fname and pid
    @plist = sort {
	$a->{sessty} cmp $b->{sessty} ||
	    $a->{sessid} cmp $b->{sessid} ||
	    $a->{fname} cmp $b->{fname} ||
	    $a->{pid} <=> $b->{pid}
    } @plist;

    # (re)fill app list control
    $lApps->DeleteAllItems;
    my $pos = 0;
    foreach my $data (@plist) {
	$lApps->InsertStringItem($pos, $data->{fname} . (exists($data->{winti}) ? '*' : ''));
	$lApps->SetItem($pos, 1, $data->{sessty});
	$lApps->SetItem($pos, 2, $data->{sessid});
	$lApps->SetItem($pos++, 3, $data->{pid});
    }

    $frProgress->Destroy;
}

# make selected window active
sub OnAppsDClick {
    my ($frame, $event) = @_;

    system(qw(wmctrl -i -a), $plist[$event->GetIndex]->{winid}) if(exists($plist[$event->GetIndex]->{winid}));
}

sub OnRecheck {
    RefreshAppsList;
}

sub OnClose {
    $app->ExitMainLoop;
}
